"use strict";
const prompt = require('prompt');
prompt.message = '';
// define prompt schema as defined in https://github.com/flatiron/prompt
const schema = {
    name: 'input',
    description: 'Y/N?',
    type: 'string',
    pattern: /^[\y|\Y|n|N|x|X]$/, // only match y, n, or x (case insensitive)
    message: 'Please use "Y" or "N", type "X" to quit',
    required: true
}

const validInput = {
    Y: 'y',
    N: 'n'
}

const DEFAULT_MAX_RECORDS_TO_STORE = 1000;

/**
 * PredectiveEngine class to store all data and perform engine computations to 
 * predict what the user will guess.
 */
class PredictiveEngine {
    /**
     * Create a new Engine and initialize class variables. 'guesses' is the number of guesses of each 
     * variety, keyed by the value of the guess itself. 'guessOrder' is an array of historical 
     * guesses used for making predictions.
     */
    constructor(maxRecordsToStore) {
        this.guesses = { y: 0, n: 0 };
        this.guessOrder = [];
        this.rightInARow = 0;
        this.totalNumGuesses = 0;
        this.totalCorrect = 0;
        if (maxRecordsToStore < 1) {
            throw(`Error: Please initialize PredectiveEngine with at least 1, you provided ${maxRecordsToStore}`);
        }
        this.maxRecordsToStore = maxRecordsToStore ? maxRecordsToStore : DEFAULT_MAX_RECORDS_TO_STORE;
    }

    /**
     * Reinitialize values after certain time. This is used to keep the stack from overflowing
     * the memory. This is also user configured so it can be set based on the requirements of 
     * the user.
     */
    checkAndCleanStorage() {
        if (this.guessOrder.length === this.maxRecordsToStore) {
            this.guessOrder = [];
            this.guesses = { y: 0, n: 0 };
        }
    }

    /**
     * Function for processing user input and comparing it to the engine's guess.
     * @param {string} input - User input to process.
     * @param {string} guess - Guess to compare user input to (should be generated by engine).
     * @returns {string} Returns the output to display to the user, based on the input compared to
     * what the engine guessed.
     */
    processUserInput(input, guess) {
        // validate guess input to function
        if (Object.keys(validInput).map((key) => validInput[key]).indexOf(guess) === -1) {
            console.log(Object.keys(validInput).map((key) => validInput[key]));
            throw(`Error: Invalid guess ${guess} provided to engine.`);
        }

        this.checkAndCleanStorage();

        // store input into data structures
        if (input === validInput.Y) {
            this.guesses.y++;
        } else if (input === validInput.N) {
            this.guesses.n++;
        } else {
            throw(`Error: Invalid user input ${input} provided to engine.`);
        }
        this.guessOrder.push(input);

        // create prompt for user based on guess and input
        let prompt = `I guessed ${guess.toUpperCase()}, ` 
        if (input === guess) {
            this.rightInARow++;
            this.totalCorrect++;
            prompt += `Correct, ${this.rightInARow} in a row!`;
        } else {
            this.rightInARow = 0;
            prompt += 'Incorrect.';
        }
        this.totalNumGuesses++;
        return prompt;
    }

    /**
     * Function to predict what the user will input. This is a very simple algorithm that 
     * takes all of the guesses and uses a random number generator weighted based on the 
     * previous inputs. We also choose based on the user choosing multiple of the same option
     * in a row, trying to bank on them going on a "streak".
     * @returns {string} Returns 'y' or 'n' representing what the engine thinks the user will
     * input next.
     */
    predictNextInput() {
        let yProportion = 0;
        if ((this.guesses.y + this.guesses.n) > 0) {
            yProportion = this.guesses.y / (this.guesses.y + this.guesses.n);
        }
        let guess;
        const totalNumGuesses = this.guessOrder.length;
        if ((totalNumGuesses > 1) && (this.guessOrder[totalNumGuesses - 1] === this.guessOrder[totalNumGuesses - 2])) {
            guess = this.guessOrder[totalNumGuesses - 1];
        } else {
            const num = Math.random();
            if (num < yProportion) {
                guess = validInput.Y;
            } else {
                guess = validInput.N;
            }
        }
        return guess;
    } 
}

console.log('Welcome');
const predictiveEngine = new PredictiveEngine();
prompt.start();
function getInput() {
    const guess = predictiveEngine.predictNextInput();
    prompt.get(schema, (err, result) => {
        if (err) { 
            return onErr(err);
        }

        const userInput = result.input.toLowerCase();

        // x to exit
        if (userInput === 'x') {
            let prompt = `Thanks for playing! I answered ${predictiveEngine.totalCorrect} correctly out of `;
            prompt += `${predictiveEngine.totalNumGuesses}, or ${(predictiveEngine.totalCorrect / predictiveEngine.totalNumGuesses) * 100}%`;
            console.log(prompt);
            return 0;
        }

        const prompt = predictiveEngine.processUserInput(userInput, guess);
        console.log(prompt);

        // keep getting input until user quits
        getInput();
    });
}
getInput();

function onErr(err) {
    console.log(err);
    return 1;
}